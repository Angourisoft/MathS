/* 
 * Copyright (c) 2019-2021 Angouri.
 * AngouriMath is licensed under MIT. 
 * Details: https://github.com/asc-community/AngouriMath/blob/master/LICENSE.md.
 * Website: https://am.angouri.org.
 */

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>

/* THIS FILE IS AUTO-GENERATED */

using System;
using System.Numerics;

namespace AngouriMath.Core.Compilation.IntoLinq
{
    // TODO: to improve some of those functions
    internal static class MathAllMethods
    {

        /* POWERS */

        internal static Complex Log(Complex a, Complex b)
            => Complex.Log(a) / Complex.Log(b);
        internal static double Log(double a, double b)
            => Math.Log(a, b);
        internal static float Log(float a, float b)
            => (float)Math.Log(a, b);
        internal static long Log(long a, long b)
            => (long)Math.Log(a, b);
        internal static int Log(int a, int b)
            => (int)Math.Log(a, b);
        internal static BigInteger Log(BigInteger a, BigInteger b)
            => (BigInteger)Math.Log((double)a, (double)b);


        internal static Complex Pow(Complex a, Complex b)
            => Complex.Pow(a, b);
        internal static double Pow(double a, double b)
            => Math.Pow(a, b);
        internal static float Pow(float a, float b)
            => (float)Math.Pow(a, b);
        internal static long Pow(long a, long b)
            => (long)Math.Pow(a, b);
        internal static int Pow(int a, int b)
            => (int)Math.Pow(a, b);
        internal static BigInteger Pow(BigInteger a, BigInteger b)
            => (BigInteger)Math.Pow((double)a, (double)b);

        /* BUILT-IN TRIGONOMETRY */

<# foreach (var name in new[]{ "Sin", "Cos", "Tan", "Asin", "Acos", "Atan" }) { #>

        internal static Complex <#= name #>(Complex a)
            => Complex.<#= name #>(a);
        internal static double <#= name #>(double a)
            => Math.<#= name #>(a);
        internal static float <#= name #>(float a)
            => (float)Math.<#= name #>(a);
        internal static long <#= name #>(long a)
            => (long)Math.<#= name #>(a);
        internal static int <#= name #>(int a)
            => (int)Math.<#= name #>(a);
        internal static BigInteger <#= name #>(BigInteger a)
            => (BigInteger)Math.<#= name #>((double)a);

<# } #>

        /* POST-INVERSE TRIGONOMETRY */

<# foreach (var name in new[]{ ("Cot", "Tan"), ("Sec", "Cos"), ("Csc", "Sin") }) { #>

        internal static Complex <#= name.Item1 #>(Complex a)
            => 1 / Complex.<#= name.Item2 #>(a);
        internal static double <#= name.Item1 #>(double a)
            => 1 / Math.<#= name.Item2 #>(a);
        internal static float <#= name.Item1 #>(float a)
            => (float)(1 / Math.<#= name.Item2 #>(a));
        internal static long <#= name.Item1 #>(long a)
            => (long)(1 / Math.<#= name.Item2 #>(a));
        internal static int <#= name.Item1 #>(int a)
            => (int)(1 / Math.<#= name.Item2 #>(a));
        internal static BigInteger <#= name.Item1 #>(BigInteger a)
            => (BigInteger)(1 / Math.<#= name.Item2 #>((double)a));

<# } #>

        /* PRE-INVERSE TRIGONOMETRY */

<# foreach (var name in new[]{ ("Acot", "Atan"), ("Asec", "Acos"), ("Acsc", "Asin") }) { #>

        internal static Complex <#= name.Item1 #>(Complex a)
            => Complex.<#= name.Item2 #>(1 / a);
        internal static double <#= name.Item1 #>(double a)
            => Math.<#= name.Item2 #>(1 / a);
        internal static float <#= name.Item1 #>(float a)
            => (float)Math.<#= name.Item2 #>(1 / a);
        internal static long <#= name.Item1 #>(long a)
            => (long)Math.<#= name.Item2 #>(1 / a);
        internal static int <#= name.Item1 #>(int a)
            => (int)Math.<#= name.Item2 #>(1 / a);
        internal static BigInteger <#= name.Item1 #>(BigInteger a)
            => (BigInteger)Math.<#= name.Item2 #>(1 / (double)a);

<# } #>
        
        /* OTHER */
        internal static Complex Abs(Complex a) => Complex.Abs(a);
        internal static double Abs(double a) => Math.Abs(a);
        internal static float Abs(float a) => Math.Abs(a);
        internal static long Abs(long a) => Math.Abs(a);
        internal static int Abs(int a) => Math.Abs(a);
        internal static BigInteger Abs(BigInteger a) => BigInteger.Abs(a);

        internal static Complex Sgn(Complex a) => a / Complex.Abs(a);
        internal static double Sgn(double a) => a switch { > 0 or double.PositiveInfinity => 1, 0 => 0, < 0 or double.NegativeInfinity => 1, _ => double.NaN };
        internal static float Sgn(float a) => a switch { > 0 or float.PositiveInfinity => 1, 0 => 0, < 0 or float.NegativeInfinity => 1, _ => float.NaN };
        internal static long Sgn(long a) => a switch { > 0 => 1, 0 => 0, < 0 => 1 };
        internal static int Sgn(int a) => a switch { > 0 => 1, 0 => 0, < 0 => 1 };
        internal static BigInteger Sgn(BigInteger a)
        {
            if (a > BigInteger.Zero)
                return 1;
            if (a < BigInteger.Zero)
                return -1;
            return 0;
        }
    }
}
