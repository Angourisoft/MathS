using AngouriMath.Core.Exceptions;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace AngouriMath.Core.Multithreading
{
    /// <summary>
    /// This tiny wrapper allows not only to get a Task,
    /// but also to stop it, as inside it has the cancellation
    /// token
    /// </summary>
    /// <typeparam name="TTask">
    /// Either Task or Task with some generic type
    /// </typeparam>
    public struct TaskHolder<TTask> where TTask : Task
    {
        /// <returns>An inner task generated by Task.Run</returns>
        public TTask Task { get; }
        /// <returns>An inner token used inside functions of AM</returns>
        public CancellationTokenSource? CancellationTokenSource { get; }
        internal TaskHolder(TTask task, CancellationTokenSource token)
        {
            Task = task;
            CancellationTokenSource = token;
        }

        /// <summary>
        /// Silently stops the execution or throws the inner exception
        /// of the aggregate one
        /// </summary>
        public void Cancel()
        {
            if (CancellationTokenSource is null)
                throw new NoTaskToCancelException();
            try
            {
                CancellationTokenSource.Cancel();
                Task.Wait();
            }
            catch (AggregateException aggregate)
            {
                if (aggregate.InnerException is not OperationCanceledException)
                    throw aggregate.InnerException ?? aggregate;
            }
        }
    }

    internal static class MultithreadingFunctional
    {
        [ThreadStatic] private static CancellationToken globalCancellationToken;
        [ConstantField] private static CancellationToken alwaysNotRequested = new CancellationTokenSource().Token;

        internal static TaskHolder<Task> RunAsync(Action action)
        {
            var tokenToAssign = new CancellationTokenSource();
            var token = tokenToAssign.Token;
            return new TaskHolder<Task>(Task.Run(
                () =>
                {
                    globalCancellationToken = token;
                    try
                    {
                        action();
                    }
                    finally
                    {
                        globalCancellationToken = alwaysNotRequested;
                    }
                },
                token), tokenToAssign);
        }

        internal static TaskHolder<Task<T>> RunAsync<T>(Func<T> action)
        {
            var tokenToAssign = new CancellationTokenSource();
            var token = tokenToAssign.Token;
            return new TaskHolder<Task<T>>(Task.Run(
                () =>
                {
                    globalCancellationToken = token;
                    try
                    {
                        return action();
                    }
                    finally
                    {
                        globalCancellationToken = alwaysNotRequested;
                    }
                },
                token), tokenToAssign);
        }

        // Inject this code in places where the function might potentially get stuck
        internal static void ExitIfCancelled()
        {
            globalCancellationToken.ThrowIfCancellationRequested();
        }
    }
}
